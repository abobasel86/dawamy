{"version":3,"file":"webpass.mjs","sources":["../node_modules/@simplewebauthn/browser/dist/bundle/index.js","../src/browser.ts","../src/utils.ts","../src/config.ts","../node_modules/destr/dist/index.mjs","../node_modules/ufo/dist/index.mjs","../node_modules/ofetch/dist/shared/ofetch.00501375.mjs","../node_modules/ofetch/dist/index.mjs","../src/wfetch.ts","../src/csrf.ts","../src/benchmark.ts","../src/webpass.ts"],"sourcesContent":["/* [@simplewebauthn/browser@10.0.0] */\nfunction bufferToBase64URLString(buffer) {\n    const bytes = new Uint8Array(buffer);\n    let str = '';\n    for (const charCode of bytes) {\n        str += String.fromCharCode(charCode);\n    }\n    const base64String = btoa(str);\n    return base64String.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');\n}\n\nfunction base64URLStringToBuffer(base64URLString) {\n    const base64 = base64URLString.replace(/-/g, '+').replace(/_/g, '/');\n    const padLength = (4 - (base64.length % 4)) % 4;\n    const padded = base64.padEnd(base64.length + padLength, '=');\n    const binary = atob(padded);\n    const buffer = new ArrayBuffer(binary.length);\n    const bytes = new Uint8Array(buffer);\n    for (let i = 0; i < binary.length; i++) {\n        bytes[i] = binary.charCodeAt(i);\n    }\n    return buffer;\n}\n\nfunction browserSupportsWebAuthn() {\n    return (window?.PublicKeyCredential !== undefined &&\n        typeof window.PublicKeyCredential === 'function');\n}\n\nfunction toPublicKeyCredentialDescriptor(descriptor) {\n    const { id } = descriptor;\n    return {\n        ...descriptor,\n        id: base64URLStringToBuffer(id),\n        transports: descriptor.transports,\n    };\n}\n\nfunction isValidDomain(hostname) {\n    return (hostname === 'localhost' ||\n        /^([a-z0-9]+(-[a-z0-9]+)*\\.)+[a-z]{2,}$/i.test(hostname));\n}\n\nclass WebAuthnError extends Error {\n    constructor({ message, code, cause, name, }) {\n        super(message, { cause });\n        this.name = name ?? cause.name;\n        this.code = code;\n    }\n}\n\nfunction identifyRegistrationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Registration ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'ConstraintError') {\n        if (publicKey.authenticatorSelection?.requireResidentKey === true) {\n            return new WebAuthnError({\n                message: 'Discoverable credentials were required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT',\n                cause: error,\n            });\n        }\n        else if (publicKey.authenticatorSelection?.userVerification === 'required') {\n            return new WebAuthnError({\n                message: 'User verification was required but no available authenticator supported it',\n                code: 'ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'InvalidStateError') {\n        return new WebAuthnError({\n            message: 'The authenticator was previously registered',\n            code: 'ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'NotSupportedError') {\n        const validPubKeyCredParams = publicKey.pubKeyCredParams.filter((param) => param.type === 'public-key');\n        if (validPubKeyCredParams.length === 0) {\n            return new WebAuthnError({\n                message: 'No entry in pubKeyCredParams was of type \"public-key\"',\n                code: 'ERROR_MALFORMED_PUBKEYCREDPARAMS',\n                cause: error,\n            });\n        }\n        return new WebAuthnError({\n            message: 'No available authenticator supported any of the specified pubKeyCredParams algorithms',\n            code: 'ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rp.id !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rp.id}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'TypeError') {\n        if (publicKey.user.id.byteLength < 1 || publicKey.user.id.byteLength > 64) {\n            return new WebAuthnError({\n                message: 'User ID was not between 1 and 64 characters',\n                code: 'ERROR_INVALID_USER_ID_LENGTH',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new credential',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nclass BaseWebAuthnAbortService {\n    createNewAbortSignal() {\n        if (this.controller) {\n            const abortError = new Error('Cancelling existing WebAuthn API call for new one');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n        }\n        const newController = new AbortController();\n        this.controller = newController;\n        return newController.signal;\n    }\n    cancelCeremony() {\n        if (this.controller) {\n            const abortError = new Error('Manually cancelling existing WebAuthn API call');\n            abortError.name = 'AbortError';\n            this.controller.abort(abortError);\n            this.controller = undefined;\n        }\n    }\n}\nconst WebAuthnAbortService = new BaseWebAuthnAbortService();\n\nconst attachments = ['cross-platform', 'platform'];\nfunction toAuthenticatorAttachment(attachment) {\n    if (!attachment) {\n        return;\n    }\n    if (attachments.indexOf(attachment) < 0) {\n        return;\n    }\n    return attachment;\n}\n\nasync function startRegistration(optionsJSON) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        user: {\n            ...optionsJSON.user,\n            id: base64URLStringToBuffer(optionsJSON.user.id),\n        },\n        excludeCredentials: optionsJSON.excludeCredentials?.map(toPublicKeyCredentialDescriptor),\n    };\n    const options = { publicKey };\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.create(options));\n    }\n    catch (err) {\n        throw identifyRegistrationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Registration was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let transports = undefined;\n    if (typeof response.getTransports === 'function') {\n        transports = response.getTransports();\n    }\n    let responsePublicKeyAlgorithm = undefined;\n    if (typeof response.getPublicKeyAlgorithm === 'function') {\n        try {\n            responsePublicKeyAlgorithm = response.getPublicKeyAlgorithm();\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKeyAlgorithm()', error);\n        }\n    }\n    let responsePublicKey = undefined;\n    if (typeof response.getPublicKey === 'function') {\n        try {\n            const _publicKey = response.getPublicKey();\n            if (_publicKey !== null) {\n                responsePublicKey = bufferToBase64URLString(_publicKey);\n            }\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getPublicKey()', error);\n        }\n    }\n    let responseAuthenticatorData;\n    if (typeof response.getAuthenticatorData === 'function') {\n        try {\n            responseAuthenticatorData = bufferToBase64URLString(response.getAuthenticatorData());\n        }\n        catch (error) {\n            warnOnBrokenImplementation('getAuthenticatorData()', error);\n        }\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            attestationObject: bufferToBase64URLString(response.attestationObject),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            transports,\n            publicKeyAlgorithm: responsePublicKeyAlgorithm,\n            publicKey: responsePublicKey,\n            authenticatorData: responseAuthenticatorData,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\nfunction warnOnBrokenImplementation(methodName, cause) {\n    console.warn(`The browser extension that intercepted this WebAuthn API call incorrectly implemented ${methodName}. You should report this error to them.\\n`, cause);\n}\n\nfunction browserSupportsWebAuthnAutofill() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    const globalPublicKeyCredential = window\n        .PublicKeyCredential;\n    if (globalPublicKeyCredential.isConditionalMediationAvailable === undefined) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return globalPublicKeyCredential.isConditionalMediationAvailable();\n}\n\nfunction identifyAuthenticationError({ error, options, }) {\n    const { publicKey } = options;\n    if (!publicKey) {\n        throw Error('options was missing required publicKey property');\n    }\n    if (error.name === 'AbortError') {\n        if (options.signal instanceof AbortSignal) {\n            return new WebAuthnError({\n                message: 'Authentication ceremony was sent an abort signal',\n                code: 'ERROR_CEREMONY_ABORTED',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'NotAllowedError') {\n        return new WebAuthnError({\n            message: error.message,\n            code: 'ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY',\n            cause: error,\n        });\n    }\n    else if (error.name === 'SecurityError') {\n        const effectiveDomain = window.location.hostname;\n        if (!isValidDomain(effectiveDomain)) {\n            return new WebAuthnError({\n                message: `${window.location.hostname} is an invalid domain`,\n                code: 'ERROR_INVALID_DOMAIN',\n                cause: error,\n            });\n        }\n        else if (publicKey.rpId !== effectiveDomain) {\n            return new WebAuthnError({\n                message: `The RP ID \"${publicKey.rpId}\" is invalid for this domain`,\n                code: 'ERROR_INVALID_RP_ID',\n                cause: error,\n            });\n        }\n    }\n    else if (error.name === 'UnknownError') {\n        return new WebAuthnError({\n            message: 'The authenticator was unable to process the specified options, or could not create a new assertion signature',\n            code: 'ERROR_AUTHENTICATOR_GENERAL_ERROR',\n            cause: error,\n        });\n    }\n    return error;\n}\n\nasync function startAuthentication(optionsJSON, useBrowserAutofill = false) {\n    if (!browserSupportsWebAuthn()) {\n        throw new Error('WebAuthn is not supported in this browser');\n    }\n    let allowCredentials;\n    if (optionsJSON.allowCredentials?.length !== 0) {\n        allowCredentials = optionsJSON.allowCredentials?.map(toPublicKeyCredentialDescriptor);\n    }\n    const publicKey = {\n        ...optionsJSON,\n        challenge: base64URLStringToBuffer(optionsJSON.challenge),\n        allowCredentials,\n    };\n    const options = {};\n    if (useBrowserAutofill) {\n        if (!(await browserSupportsWebAuthnAutofill())) {\n            throw Error('Browser does not support WebAuthn autofill');\n        }\n        const eligibleInputs = document.querySelectorAll(\"input[autocomplete$='webauthn']\");\n        if (eligibleInputs.length < 1) {\n            throw Error('No <input> with \"webauthn\" as the only or last value in its `autocomplete` attribute was detected');\n        }\n        options.mediation = 'conditional';\n        publicKey.allowCredentials = [];\n    }\n    options.publicKey = publicKey;\n    options.signal = WebAuthnAbortService.createNewAbortSignal();\n    let credential;\n    try {\n        credential = (await navigator.credentials.get(options));\n    }\n    catch (err) {\n        throw identifyAuthenticationError({ error: err, options });\n    }\n    if (!credential) {\n        throw new Error('Authentication was not completed');\n    }\n    const { id, rawId, response, type } = credential;\n    let userHandle = undefined;\n    if (response.userHandle) {\n        userHandle = bufferToBase64URLString(response.userHandle);\n    }\n    return {\n        id,\n        rawId: bufferToBase64URLString(rawId),\n        response: {\n            authenticatorData: bufferToBase64URLString(response.authenticatorData),\n            clientDataJSON: bufferToBase64URLString(response.clientDataJSON),\n            signature: bufferToBase64URLString(response.signature),\n            userHandle,\n        },\n        type,\n        clientExtensionResults: credential.getClientExtensionResults(),\n        authenticatorAttachment: toAuthenticatorAttachment(credential.authenticatorAttachment),\n    };\n}\n\nfunction platformAuthenticatorIsAvailable() {\n    if (!browserSupportsWebAuthn()) {\n        return new Promise((resolve) => resolve(false));\n    }\n    return PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();\n}\n\nexport { WebAuthnAbortService, WebAuthnError, base64URLStringToBuffer, browserSupportsWebAuthn, browserSupportsWebAuthnAutofill, bufferToBase64URLString, platformAuthenticatorIsAvailable, startAuthentication, startRegistration };\n","import {\n    browserSupportsWebAuthn,\n    browserSupportsWebAuthnAutofill,\n    platformAuthenticatorIsAvailable\n} from \"@simplewebauthn/browser\";\n\n/**\n * Check if the browser supports WebAuthn\n *\n * @return {boolean}\n */\nexport function isSupported(): boolean {\n    return browserSupportsWebAuthn()\n}\n\n/**\n * Check if the browser doesn't support WebAuthn\n */\nexport function isNotSupported(): boolean {\n    return ! isSupported()\n}\n\n/**\n * Check if the browser doesn't support WebAuthn\n */\nexport function isUnsupported(): boolean {\n    return ! isSupported()\n}\n\n/**\n * Check if the browser can show an autofill dialog with existing Passkeys.\n *\n * @see https://web.dev/articles/passkey-form-autofill\n */\nexport async function isAutofillable(): Promise<boolean> {\n    return isSupported() && await browserSupportsWebAuthnAutofill()\n}\n\n/**\n * Check if the browser cannot show an autofill dialog with existing Passkeys.\n *\n * @see https://web.dev/articles/passkey-form-autofill\n */\nexport async function isNotAutofillable(): Promise<boolean> {\n    return ! await isAutofillable()\n}\n\n/**\n * Check if the browser is on device compatible with Touch ID, Face ID, Windows Hello, or others.\n */\nexport async function isPlatformAuthenticator(): Promise<boolean> {\n    return isSupported() && await platformAuthenticatorIsAvailable()\n}\n\n/**\n * Check if the browser is not on device compatible with Touch ID, Face ID, Windows Hello, or others.\n */\nexport async function isNotPlatformAuthenticator(): Promise<boolean> {\n    return ! await isPlatformAuthenticator()\n}\n","import {CeremonyOptions, CeremonyOptionsWithoutPath, Config} from \"./types\"\n\n/**\n * Extracts a single key for the object.\n */\nexport function pull<T extends Record<string, any>, K extends keyof T>(object: T, key: K): T[K] {\n    const extracted = object[key]\n\n    delete object[key]\n\n    return extracted\n}\n\n/**\n * Return all object keys except the ones issued.\n */\nexport function except<T extends Record<string, any>, K extends Array<keyof T>>(object: T, ...keys: K): Partial<T> {\n    const result: Partial<T> = {};\n\n    const allKeys = Object.keys(object) as K\n\n    for (const key of allKeys) {\n        if (!keys.includes(key)) {\n            result[key] = object[key];\n        }\n    }\n\n    return result;\n}\n\n/**\n * Check if an object is a non-empty object.\n */\nexport function isObjectEmpty(value: any): boolean {\n    return typeof value === \"object\" && !Object.keys(value).length\n}\n\n/**\n * Deeply merge an object with another object.\n */\nexport function mergeDeep<T extends Record<string, any>, S extends Record<string, any>>(target: T, source: S): T & S {\n    if (!isObject(target)) {\n        return mergeDeep({}, source) as T & S\n    }\n\n    const output: Record<string, any> = Object.assign({}, target)\n\n    if (isObject(source)) {\n        Object.keys(source).forEach((key: string): void => {\n            if (isObject(source[key])) {\n                if (!(key in target)) {\n                    Object.assign(output, {[key]: source[key]})\n                } else {\n                    output[key] = mergeDeep(target[key], source[key])\n                }\n            } else {\n                Object.assign(output, {[key]: source[key]})\n            }\n        })\n    }\n\n    return output as T & S\n}\n\n/**\n * Check if the value is an object\n */\nfunction isObject(obj: any): boolean {\n    return obj !== null && !Array.isArray(obj) && typeof obj === \"object\" && typeof obj !== \"function\"\n}\n\n/**\n * Normalize the Ceremony options to something fetch-able.\n */\nexport function normalizeOptions(\n    options: CeremonyOptionsWithoutPath | string | undefined | null,\n    config: Config,\n    defaultPathKey: keyof typeof config.routes\n): CeremonyOptions {\n    // If the options are empty, create a string with the default route\n    if (!options) {\n        options = config.routes[defaultPathKey]\n    }\n\n    // If the option is a string, create an object with the string as path\n    if (typeof options === \"string\") {\n        options = { path: options }\n    }\n\n    // If the path in the object is empty, assign it the default route\n    options.path = options.path || config.routes[defaultPathKey]\n    options.baseURL = options.baseURL || config.baseURL || window.location.origin\n\n    // Set the defaults for the object if these are \"falsy\"\n    options.body = options.body || {}\n    options.method = options.method || config.method\n    options.headers = options.headers || config.headers\n    options.redirect = options.redirect || config.redirect\n    options.credentials = options.credentials || config.credentials\n\n    return options as CeremonyOptions\n}\n","import type {Config} from \"./types\"\n\n/**\n * Default configuration.\n *\n * @type {Config}\n */\nexport default {\n    method: \"post\",\n    redirect: \"error\",\n    baseURL: undefined,\n    findCsrfToken: false,\n    findXsrfToken: false,\n    useAutofill: undefined,\n    routes: {\n        attestOptions: \"/auth/attest-options\",\n        attest: \"/auth/attest\",\n        assertOptions: \"/auth/assert-options\",\n        assert: \"/auth/assert\",\n    },\n    headers: {\n        \"Accept\": \"application/json\",\n        \"Content-Type\": \"application/json\",\n        \"X-Requested-With\": \"XMLHttpRequest\"\n    },\n    credentials: \"same-origin\",\n} as Config\n","const suspectProtoRx = /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nconst JsonSigRx = /^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\nfunction jsonParseTransform(key, value) {\n  if (key === \"__proto__\" || key === \"constructor\" && value && typeof value === \"object\" && \"prototype\" in value) {\n    warnKeyDropped(key);\n    return;\n  }\n  return value;\n}\nfunction warnKeyDropped(key) {\n  console.warn(`[destr] Dropping \"${key}\" key to prevent prototype pollution.`);\n}\nfunction destr(value, options = {}) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  const _value = value.trim();\n  if (\n    // eslint-disable-next-line unicorn/prefer-at\n    value[0] === '\"' && value.at(-1) === '\"' && !value.includes(\"\\\\\")\n  ) {\n    return _value.slice(1, -1);\n  }\n  if (_value.length <= 9) {\n    const _lval = _value.toLowerCase();\n    if (_lval === \"true\") {\n      return true;\n    }\n    if (_lval === \"false\") {\n      return false;\n    }\n    if (_lval === \"undefined\") {\n      return void 0;\n    }\n    if (_lval === \"null\") {\n      return null;\n    }\n    if (_lval === \"nan\") {\n      return Number.NaN;\n    }\n    if (_lval === \"infinity\") {\n      return Number.POSITIVE_INFINITY;\n    }\n    if (_lval === \"-infinity\") {\n      return Number.NEGATIVE_INFINITY;\n    }\n  }\n  if (!JsonSigRx.test(value)) {\n    if (options.strict) {\n      throw new SyntaxError(\"[destr] Invalid JSON\");\n    }\n    return value;\n  }\n  try {\n    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {\n      if (options.strict) {\n        throw new Error(\"[destr] Possible prototype pollution\");\n      }\n      return JSON.parse(value, jsonParseTransform);\n    }\n    return JSON.parse(value);\n  } catch (error) {\n    if (options.strict) {\n      throw error;\n    }\n    return value;\n  }\n}\nfunction safeDestr(value, options = {}) {\n  return destr(value, { ...options, strict: true });\n}\n\nexport { destr as default, destr, safeDestr };\n","const n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = {\n  overflow: \"Overflow Error\",\n  \"not-basic\": \"Illegal Input\",\n  \"invalid-input\": \"Invalid Input\"\n};\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_CARET_RE = /%5e/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7b/gi;\nconst ENC_PIPE_RE = /%7c/gi;\nconst ENC_CURLY_CLOSE_RE = /%7d/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2f/gi;\nconst ENC_ENC_SLASH_RE = /%252f/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(input) {\n  return encode(typeof input === \"string\" ? input : JSON.stringify(input)).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryKey(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(parametersString = \"\") {\n  const object = {};\n  if (parametersString[0] === \"?\") {\n    parametersString = parametersString.slice(1);\n  }\n  for (const parameter of parametersString.split(\"&\")) {\n    const s = parameter.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decodeQueryKey(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (object[key] === void 0) {\n      object[key] = value;\n    } else if (Array.isArray(object[key])) {\n      object[key].push(value);\n    } else {\n      object[key] = [object[key], value];\n    }\n  }\n  return object;\n}\nfunction encodeQueryItem(key, value) {\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    value = String(value);\n  }\n  if (!value) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(value)) {\n    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join(\"&\");\n}\n\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass $URL {\n  constructor(input = \"\") {\n    __publicField(this, \"protocol\");\n    __publicField(this, \"host\");\n    __publicField(this, \"auth\");\n    __publicField(this, \"pathname\");\n    __publicField(this, \"query\", {});\n    __publicField(this, \"hash\");\n    if (typeof input !== \"string\") {\n      throw new TypeError(\n        `URL input should be string received ${typeof input} (${input})`\n      );\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length > 0 ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        for (const v of value) {\n          p.append(name, v);\n        }\n      } else {\n        p.append(\n          name,\n          typeof value === \"string\" ? value : JSON.stringify(value)\n        );\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\n\nfunction isRelative(inputString) {\n  return [\"./\", \"../\"].some((string_) => inputString.startsWith(string_));\n}\nconst PROTOCOL_STRICT_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{1,2})/;\nconst PROTOCOL_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{2})?/;\nconst PROTOCOL_RELATIVE_REGEX = /^([/\\\\]\\s*){2,}[^/\\\\]/;\nfunction hasProtocol(inputString, opts = {}) {\n  if (typeof opts === \"boolean\") {\n    opts = { acceptRelative: opts };\n  }\n  if (opts.strict) {\n    return PROTOCOL_STRICT_REGEX.test(inputString);\n  }\n  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);\n}\nconst PROTOCOL_SCRIPT_RE = /^[\\s\\0]*(blob|data|javascript|vbscript):$/i;\nfunction isScriptProtocol(protocol) {\n  return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);\n}\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?|\\/#/;\nfunction hasTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction withTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex >= 0) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n    if (!path) {\n      return fragment;\n    }\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.slice(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nconst JOIN_LEADING_SLASH_RE = /^\\.?\\//;\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {\n    if (url) {\n      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, \"\");\n      url = withTrailingSlash(url) + _segment;\n    } else {\n      url = segment;\n    }\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  const match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.slice(match[0].length);\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\nfunction normalizeURL(input) {\n  return createURL(input).toString();\n}\nfunction resolveURL(base, ...input) {\n  const url = createURL(base);\n  for (const index of input.filter((url2) => isNonEmptyURL(url2))) {\n    url.append(createURL(index));\n  }\n  return url.toString();\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, options = {}) {\n  if (!options.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!options.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!options.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\n\nfunction parseURL(input = \"\", defaultProto) {\n  const _specialProtoMatch = input.match(\n    /^[\\s\\0]*(blob:|data:|javascript:|vbscript:)(.*)/i\n  );\n  if (_specialProtoMatch) {\n    const [, _proto, _pathname = \"\"] = _specialProtoMatch;\n    return {\n      protocol: _proto.toLowerCase(),\n      pathname: _pathname,\n      href: _proto + _pathname,\n      auth: \"\",\n      host: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n  }\n  if (!hasProtocol(input, { acceptRelative: true })) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [, protocol = \"\", auth, hostAndPath = \"\"] = input.replace(/\\\\/g, \"/\").match(/^[\\s\\0]*([\\w+.-]{2,}:)?\\/\\/([^/@]+@)?(.*)/) || [];\n  const [, host = \"\", path = \"\"] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];\n  const { pathname, search, hash } = parsePath(\n    path.replace(/\\/(?=[A-Za-z]:)/, \"\")\n  );\n  return {\n    protocol: protocol.toLowerCase(),\n    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : \"\",\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/:]*):?(\\d+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const pathname = parsed.pathname || \"\";\n  const search = parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\";\n  const hash = parsed.hash || \"\";\n  const auth = parsed.auth ? parsed.auth + \"@\" : \"\";\n  const host = parsed.host || \"\";\n  const proto = parsed.protocol ? parsed.protocol + \"//\" : \"\";\n  return proto + auth + host + pathname + search + hash;\n}\nconst FILENAME_STRICT_REGEX = /\\/([^/]+\\.[^/]+)$/;\nconst FILENAME_REGEX = /\\/([^/]+)$/;\nfunction parseFilename(input = \"\", { strict }) {\n  const { pathname } = parseURL(input);\n  const matches = strict ? pathname.match(FILENAME_STRICT_REGEX) : pathname.match(FILENAME_REGEX);\n  return matches ? matches[1] : void 0;\n}\n\nexport { $URL, cleanDoubleSlashes, createURL, decode, decodePath, decodeQueryKey, decodeQueryValue, encode, encodeHash, encodeHost, encodeParam, encodePath, encodeQueryItem, encodeQueryKey, encodeQueryValue, getQuery, hasLeadingSlash, hasProtocol, hasTrailingSlash, isEmptyURL, isEqual, isNonEmptyURL, isRelative, isSamePath, isScriptProtocol, joinURL, normalizeURL, parseAuth, parseFilename, parseHost, parsePath, parseQuery, parseURL, resolveURL, stringifyParsedURL, stringifyQuery, withBase, withHttp, withHttps, withLeadingSlash, withProtocol, withQuery, withTrailingSlash, withoutBase, withoutLeadingSlash, withoutProtocol, withoutTrailingSlash };\n","import destr from 'destr';\nimport { withBase, withQuery } from 'ufo';\n\nclass FetchError extends Error {\n  constructor(message, opts) {\n    super(message, opts);\n    this.name = \"FetchError\";\n    if (opts?.cause && !this.cause) {\n      this.cause = opts.cause;\n    }\n  }\n}\nfunction createFetchError(ctx) {\n  const errorMessage = ctx.error?.message || ctx.error?.toString() || \"\";\n  const method = ctx.request?.method || ctx.options?.method || \"GET\";\n  const url = ctx.request?.url || String(ctx.request) || \"/\";\n  const requestStr = `[${method}] ${JSON.stringify(url)}`;\n  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : \"<no response>\";\n  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : \"\"}`;\n  const fetchError = new FetchError(\n    message,\n    ctx.error ? { cause: ctx.error } : void 0\n  );\n  for (const key of [\"request\", \"options\", \"response\"]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx[key];\n      }\n    });\n  }\n  for (const [key, refKey] of [\n    [\"data\", \"_data\"],\n    [\"status\", \"status\"],\n    [\"statusCode\", \"status\"],\n    [\"statusText\", \"statusText\"],\n    [\"statusMessage\", \"statusText\"]\n  ]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx.response && ctx.response[refKey];\n      }\n    });\n  }\n  return fetchError;\n}\n\nconst payloadMethods = new Set(\n  Object.freeze([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"])\n);\nfunction isPayloadMethod(method = \"GET\") {\n  return payloadMethods.has(method.toUpperCase());\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nconst textTypes = /* @__PURE__ */ new Set([\n  \"image/svg\",\n  \"application/xml\",\n  \"application/xhtml\",\n  \"application/html\"\n]);\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(_contentType = \"\") {\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\nfunction mergeFetchOptions(input, defaults, Headers = globalThis.Headers) {\n  const merged = {\n    ...defaults,\n    ...input\n  };\n  if (defaults?.params && input?.params) {\n    merged.params = {\n      ...defaults?.params,\n      ...input?.params\n    };\n  }\n  if (defaults?.query && input?.query) {\n    merged.query = {\n      ...defaults?.query,\n      ...input?.query\n    };\n  }\n  if (defaults?.headers && input?.headers) {\n    merged.headers = new Headers(defaults?.headers || {});\n    for (const [key, value] of new Headers(input?.headers || {})) {\n      merged.headers.set(key, value);\n    }\n  }\n  return merged;\n}\n\nconst retryStatusCodes = /* @__PURE__ */ new Set([\n  408,\n  // Request Timeout\n  409,\n  // Conflict\n  425,\n  // Too Early\n  429,\n  // Too Many Requests\n  500,\n  // Internal Server Error\n  502,\n  // Bad Gateway\n  503,\n  // Service Unavailable\n  504\n  //  Gateway Timeout\n]);\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\nfunction createFetch(globalOptions = {}) {\n  const {\n    fetch = globalThis.fetch,\n    Headers = globalThis.Headers,\n    AbortController = globalThis.AbortController\n  } = globalOptions;\n  async function onError(context) {\n    const isAbort = context.error && context.error.name === \"AbortError\" && !context.options.timeout || false;\n    if (context.options.retry !== false && !isAbort) {\n      let retries;\n      if (typeof context.options.retry === \"number\") {\n        retries = context.options.retry;\n      } else {\n        retries = isPayloadMethod(context.options.method) ? 0 : 1;\n      }\n      const responseCode = context.response && context.response.status || 500;\n      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {\n        const retryDelay = context.options.retryDelay || 0;\n        if (retryDelay > 0) {\n          await new Promise((resolve) => setTimeout(resolve, retryDelay));\n        }\n        return $fetchRaw(context.request, {\n          ...context.options,\n          retry: retries - 1,\n          timeout: context.options.timeout\n        });\n      }\n    }\n    const error = createFetchError(context);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(error, $fetchRaw);\n    }\n    throw error;\n  }\n  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {\n    const context = {\n      request: _request,\n      options: mergeFetchOptions(_options, globalOptions.defaults, Headers),\n      response: void 0,\n      error: void 0\n    };\n    context.options.method = context.options.method?.toUpperCase();\n    if (context.options.onRequest) {\n      await context.options.onRequest(context);\n    }\n    if (typeof context.request === \"string\") {\n      if (context.options.baseURL) {\n        context.request = withBase(context.request, context.options.baseURL);\n      }\n      if (context.options.query || context.options.params) {\n        context.request = withQuery(context.request, {\n          ...context.options.params,\n          ...context.options.query\n        });\n      }\n    }\n    if (context.options.body && isPayloadMethod(context.options.method)) {\n      if (isJSONSerializable(context.options.body)) {\n        context.options.body = typeof context.options.body === \"string\" ? context.options.body : JSON.stringify(context.options.body);\n        context.options.headers = new Headers(context.options.headers || {});\n        if (!context.options.headers.has(\"content-type\")) {\n          context.options.headers.set(\"content-type\", \"application/json\");\n        }\n        if (!context.options.headers.has(\"accept\")) {\n          context.options.headers.set(\"accept\", \"application/json\");\n        }\n      } else if (\n        // ReadableStream Body\n        \"pipeTo\" in context.options.body && typeof context.options.body.pipeTo === \"function\" || // Node.js Stream Body\n        typeof context.options.body.pipe === \"function\"\n      ) {\n        if (!(\"duplex\" in context.options)) {\n          context.options.duplex = \"half\";\n        }\n      }\n    }\n    if (!context.options.signal && context.options.timeout) {\n      const controller = new AbortController();\n      setTimeout(() => controller.abort(), context.options.timeout);\n      context.options.signal = controller.signal;\n    }\n    try {\n      context.response = await fetch(\n        context.request,\n        context.options\n      );\n    } catch (error) {\n      context.error = error;\n      if (context.options.onRequestError) {\n        await context.options.onRequestError(context);\n      }\n      return await onError(context);\n    }\n    const hasBody = context.response.body && !nullBodyResponses.has(context.response.status) && context.options.method !== \"HEAD\";\n    if (hasBody) {\n      const responseType = (context.options.parseResponse ? \"json\" : context.options.responseType) || detectResponseType(context.response.headers.get(\"content-type\") || \"\");\n      switch (responseType) {\n        case \"json\": {\n          const data = await context.response.text();\n          const parseFunction = context.options.parseResponse || destr;\n          context.response._data = parseFunction(data);\n          break;\n        }\n        case \"stream\": {\n          context.response._data = context.response.body;\n          break;\n        }\n        default: {\n          context.response._data = await context.response[responseType]();\n        }\n      }\n    }\n    if (context.options.onResponse) {\n      await context.options.onResponse(context);\n    }\n    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {\n      if (context.options.onResponseError) {\n        await context.options.onResponseError(context);\n      }\n      return await onError(context);\n    }\n    return context.response;\n  };\n  const $fetch = async function $fetch2(request, options) {\n    const r = await $fetchRaw(request, options);\n    return r._data;\n  };\n  $fetch.raw = $fetchRaw;\n  $fetch.native = (...args) => fetch(...args);\n  $fetch.create = (defaultOptions = {}) => createFetch({\n    ...globalOptions,\n    defaults: {\n      ...globalOptions.defaults,\n      ...defaultOptions\n    }\n  });\n  return $fetch;\n}\n\nexport { FetchError as F, createFetchError as a, createFetch as c };\n","import { c as createFetch } from './shared/ofetch.00501375.mjs';\nexport { F as FetchError, a as createFetchError } from './shared/ofetch.00501375.mjs';\nimport 'destr';\nimport 'ufo';\n\nconst _globalThis = function() {\n  if (typeof globalThis !== \"undefined\") {\n    return globalThis;\n  }\n  if (typeof self !== \"undefined\") {\n    return self;\n  }\n  if (typeof window !== \"undefined\") {\n    return window;\n  }\n  if (typeof global !== \"undefined\") {\n    return global;\n  }\n  throw new Error(\"unable to locate global object\");\n}();\nconst fetch = _globalThis.fetch || (() => Promise.reject(new Error(\"[ofetch] global.fetch is not supported!\")));\nconst Headers = _globalThis.Headers;\nconst AbortController = _globalThis.AbortController;\nconst ofetch = createFetch({ fetch, Headers, AbortController });\nconst $fetch = ofetch;\n\nexport { $fetch, AbortController, Headers, createFetch, fetch, ofetch };\n","import type {CeremonyOptions, CeremonyOptionsWithoutPath } from \"./types\"\nimport {ofetch} from \"ofetch\"\nimport {mergeDeep, pull} from \"./utils\"\nimport {findTokenInCookie, findTokenInInput, findTokenInMeta, isCsrfToken} from \"./csrf\";\n\n/**\n * Check if the headers don't have a CSRF or XSRF token.\n */\nfunction missingToken(headers: Record<string, string>): boolean {\n    return ! Object.keys(headers)\n        .find((key: string): boolean => {\n            return ['x-csrf-token', 'x-xsrf-token'].includes(key.toLowerCase())\n                && !!headers[key]\n        })\n}\n\n/**\n * Pull the token configuration key out of the options\n */\nfunction pullTokenConfig(options: CeremonyOptionsWithoutPath): boolean|string {\n    return pull(options, \"findCsrfToken\") || pull(options, \"findXsrfToken\") as boolean|string\n}\n\n/**\n * Set the token in the headers if needed.\n */\nfunction setToken(token: string|boolean, headers: Record<string, string>): void {\n    // Find the token if the token is set to \"true\"\n    if (token === true && missingToken(headers)) {\n        token = findTokenInMeta() ?? findTokenInInput() ?? findTokenInCookie() ?? ''\n    }\n\n    // If the token is a string, add it verbatim to the header.\n    if (typeof token === \"string\") {\n        headers[isCsrfToken(token) ? 'X-CSRF-TOKEN' : 'X-XSRF-TOKEN'] = token\n    }\n}\n\nexport default async <T>(options: CeremonyOptions, webAuthnData: Object = {}): Promise<T> => {\n    const {path, ...fetchOptions} = options\n\n    fetchOptions.headers = fetchOptions.headers || {}\n\n    setToken(pullTokenConfig(options), fetchOptions.headers)\n\n    // @ts-ignore\n    fetchOptions.body = mergeDeep(fetchOptions.body ?? {}, webAuthnData)\n\n    return await ofetch<T>(path, fetchOptions)\n}\n","/**\n * Tries to find the CSRF token in cookies.\n */\nexport function findTokenInCookie(): string | undefined {\n    // Find a match for the CSRF-TOKEN or XSRF-TOKEN cookie, case-insensitive,\n    // as 3 groups: the whitespace preceding, the cooke name, and the value.\n    // If there is a match, decode the last group that contains the value.\n    const match: RegExpMatchArray|null = document.cookie.match(\n        new RegExp('(^|;\\\\s*)([CX]SRF-TOKEN)=([^;]*)', 'i')\n    );\n\n    return match ? decodeURIComponent(match[3]) : undefined;\n}\n\n/**\n * Find the CSRF token from a meta tag in the header.\n */\nexport function findTokenInMeta(): string | undefined {\n    return Array\n        .from(document.head.getElementsByTagName(\"meta\"))\n        .find((element: HTMLMetaElement): boolean => element.name.toLowerCase() === \"csrf-token\" && !!element.content)\n        ?.content\n}\n\n/**\n * Find the CSRF token from a meta input\n */\nexport function findTokenInInput(): string | undefined {\n    // Then, try to find a hidden input containing the CSRF token.\n    return Array\n        .from(document.body.getElementsByTagName(\"input\"))\n        .find((input: HTMLInputElement): boolean => {\n            return input.name.toLowerCase() === \"_token\"\n                && input.type.toLowerCase() === \"hidden\"\n                && !!input.value\n        })\n        ?.value\n}\n\n/**\n * Get the type of the token retrieved.\n */\nexport function isCsrfToken(token: string): boolean {\n    if (token.length < 40) {\n        const error = new Error(\"The token must be an CSRF (40 characters) or XSRF token.\")\n\n        error.name = 'InvalidToken'\n\n        throw error\n    }\n\n    return token.length === 40\n}\n","/**\n * Create a small benchmark.\n */\nexport default (): {start: Date, stop: () => string} => {\n    const start = new Date();\n\n    return {\n        start,\n        stop: (): string => {\n            const diffInMs: number = new Date().getTime() - start.getTime()\n\n            const minutes: number = Math.floor(diffInMs / 60000);\n            const seconds: number = Number(((diffInMs % 60000) / 1000).toFixed(0));\n\n            return (minutes ? minutes + ' minutes, ' : '') + (seconds ? seconds + ' seconds.' : '')\n        }\n    }\n}\n","import type {\n    AssertionResult,\n    AttestationResult,\n    CeremonyOptionsWithoutPath,\n    CeremonyResultRaw,\n    Config,\n    ServerPublicKeyCredentialCreationOptions,\n    ServerPublicKeyCredentialRequestOptions,\n    Webpass,\n    WebpassStatic\n} from \"./types\"\nimport {\n    isSupported,\n    isNotSupported,\n    isUnsupported,\n    isAutofillable,\n    isNotAutofillable,\n    isPlatformAuthenticator,\n    isNotPlatformAuthenticator\n} from \"./browser\"\nimport {isObjectEmpty, mergeDeep, normalizeOptions} from \"./utils\"\nimport defaultConfig from \"./config\"\nimport wfetch from \"./wfetch\"\nimport benchmark from \"./benchmark\"\nimport {startAuthentication, startRegistration} from \"@simplewebauthn/browser\";\nimport type {AuthenticationResponseJSON, RegistrationResponseJSON} from \"@simplewebauthn/types\";\n\n/**\n * Create a new Error with a name and message.\n */\nfunction newError(name: string, message: string, cause: unknown = undefined): Error {\n    const error = new Error(message)\n\n    error.name = name\n    error.cause = cause\n\n    return error\n}\n\n\n/**\n * Create a new Webpass instance.\n */\nfunction webpass(config: Partial<Config> = {}): Webpass {\n    // Merge the configuration\n    const currentConfig: Config = mergeDeep(structuredClone(defaultConfig), config)\n\n    /**\n     * Registers the device public key in the server and wraps the results in an object.\n     */\n    async function attest(options?: CeremonyOptionsWithoutPath | string, response?: CeremonyOptionsWithoutPath | string): Promise<AttestationResult> {\n        // Create the result we will return to the user on any scenario.\n        const result: AttestationResult = {\n            data: undefined,\n            credentials: undefined,\n            id: undefined,\n            success: false,\n            error: undefined\n        }\n\n        // Retrieve the attestation options from the server\n        try {\n            result.data = result.credentials = await attestRaw(options, response)\n        } catch (error) {\n            return {...result, error}\n        } finally {\n            result.success = result.error === undefined\n        }\n\n        // Here we will just short-circuit the ID from the response as convenience, if it exists.\n        if (typeof result.data === \"object\") {\n            result.id = result.data?.id || result.data?.uuid\n        }\n\n        return result\n    }\n\n    /**\n     * Registers the device public key in the server.\n     */\n    async function attestRaw(options?: CeremonyOptionsWithoutPath | string, response?: CeremonyOptionsWithoutPath | string): Promise<CeremonyResultRaw> {\n        const bench = benchmark()\n\n        // Normalize the arguments\n        const normalizedOptions = normalizeOptions(options, currentConfig, \"attestOptions\")\n        const normalizedResponseOptions = normalizeOptions(response, currentConfig, \"attest\")\n\n        // Retrieve the attestation options from the server\n        const attestationOptions: ServerPublicKeyCredentialCreationOptions | undefined = await wfetch<ServerPublicKeyCredentialCreationOptions | undefined>(normalizedOptions)\n\n        console.debug(\"Attestation Options Received\", attestationOptions)\n\n        // If the response is empty, bail out\n        if (!attestationOptions || isObjectEmpty(attestationOptions)) {\n            throw newError(\"InvalidAttestationResponse\", \"The server responded with invalid or empty credential creation options.\")\n        }\n\n        let credentials: RegistrationResponseJSON\n\n        try {\n            credentials = await startRegistration(attestationOptions)\n        } catch (cause) {\n            throw newError(\"AttestationCancelled\", \"The credentials creation was not completed.\", cause)\n        }\n\n        console.debug(\"Attestation Credentials Created\", credentials);\n\n        const result = await wfetch<Record<string, any>>(normalizedResponseOptions, credentials)\n\n        console.debug(\"Attestation benchmark\", bench.stop())\n\n        return result\n    }\n\n    /**\n     * Assert a WebAuthn challenge, returns the user and token or null.\n     */\n    async function assert(options?: CeremonyOptionsWithoutPath | string, response?: CeremonyOptionsWithoutPath | string): Promise<AssertionResult> {\n        // Create the result we will return to the user on any scenario.\n        const result: AssertionResult = {\n            data: undefined,\n            user: undefined,\n            token: undefined,\n            success: false,\n            error: undefined\n        }\n\n        // Get the assertion challenge from the server\n        try {\n            result.data = await assertRaw(options, response)\n        } catch (error) {\n            return {...result, error}\n        } finally {\n            result.success = result.error === undefined\n        }\n\n        // Try to set the user and token from the data received, or just the token if it's a string.\n        if (typeof result.data === \"object\") {\n            result.user = typeof result.data.user === \"object\" ? result.data.user : result.data\n            result.token = result.data?.token || result.data?.jwt\n\n            // If we couldn't get the token, try the user object if it is an object\n            if (!result.token && typeof result.user === \"object\") {\n                result.token = result.user?.token || result.user?.jwt\n            }\n        } else if (typeof result.data === \"string\") {\n            result.token = result.data\n        }\n\n        return result\n    }\n\n    /**\n     * Assert a WebAuthn challenge, returns the user and token or null.\n     */\n    async function assertRaw(options?: CeremonyOptionsWithoutPath | string, response?: CeremonyOptionsWithoutPath | string): Promise<CeremonyResultRaw> {\n        const bench = benchmark()\n\n        // Normalize the arguments\n        const normalizedOptions = normalizeOptions(options, currentConfig, \"assertOptions\")\n        const normalizedResponseOptions = normalizeOptions(response, currentConfig, \"assert\")\n\n        // Get the assertion challenge from the server\n        const assertionOptions: ServerPublicKeyCredentialRequestOptions | undefined = await wfetch<ServerPublicKeyCredentialRequestOptions | undefined>(normalizedOptions)\n\n        console.debug(\"Assertion Options Received\", assertionOptions)\n\n        // If we didn't receive anything, return it as an invalid server message.\n        if (!assertionOptions || isObjectEmpty(assertionOptions)) {\n            throw newError(\"InvalidAssertionResponse\", \"The server responded with invalid or empty credential request options.\")\n        }\n\n        let credentials: AuthenticationResponseJSON\n\n        try {\n            credentials = await startAuthentication(\n                assertionOptions,\n                normalizedOptions.useAutofill ?? normalizedResponseOptions.useAutofill ?? currentConfig.useAutofill\n            )\n        } catch (cause) {\n            throw newError(\"AssertionCancelled\", \"The credentials request was not completed.\", cause)\n        }\n\n        console.debug(\"Assertion Credentials Retrieved\", credentials)\n\n        // Expect an authentication response from the server with the user, credentials, or anything.\n        const result = await wfetch<Record<string, string>>(normalizedResponseOptions, credentials)\n\n        console.debug(\"Assertion benchmark\", bench.stop())\n\n        return result\n    }\n\n    return {\n        assert,\n        attest,\n        assertRaw,\n        attestRaw,\n    }\n}\n\nexport default {\n    create: webpass,\n    attest: async (options?, response?) => await (webpass()).attest(options, response),\n    assert: async (options?, response?) => await (webpass()).assert(options, response),\n    attestRaw: async (options?, response?) => await (webpass()).attestRaw(options, response),\n    assertRaw: async (options?, response?) => await (webpass()).assertRaw(options, response),\n    isSupported,\n    isNotSupported,\n    isUnsupported,\n    isAutofillable,\n    isNotAutofillable,\n    isPlatformAuthenticator,\n    isNotPlatformAuthenticator\n} as WebpassStatic\n"],"names":["bufferToBase64URLString","buffer","bytes","Uint8Array","str","charCode","String","fromCharCode","btoa","replace","base64URLStringToBuffer","base64URLString","base64","padLength","length","padded","padEnd","binary","atob","ArrayBuffer","i","charCodeAt","browserSupportsWebAuthn","undefined","window","PublicKeyCredential","toPublicKeyCredentialDescriptor","descriptor","id","transports","isValidDomain","hostname","test","WebAuthnError","Error","constructor","message","code","cause","name","super","this","WebAuthnAbortService","createNewAbortSignal","controller","abortError","abort","newController","AbortController","signal","cancelCeremony","attachments","toAuthenticatorAttachment","attachment","indexOf","async","startRegistration","optionsJSON","options","publicKey","challenge","user","excludeCredentials","map","credential","navigator","credentials","create","err","error","AbortSignal","authenticatorSelection","requireResidentKey","userVerification","pubKeyCredParams","filter","param","type","effectiveDomain","location","rp","byteLength","identifyRegistrationError","rawId","response","responsePublicKeyAlgorithm","responsePublicKey","responseAuthenticatorData","getTransports","getPublicKeyAlgorithm","warnOnBrokenImplementation","getPublicKey","_publicKey","getAuthenticatorData","attestationObject","clientDataJSON","publicKeyAlgorithm","authenticatorData","clientExtensionResults","getClientExtensionResults","authenticatorAttachment","methodName","console","warn","browserSupportsWebAuthnAutofill","Promise","resolve","globalPublicKeyCredential","isConditionalMediationAvailable","startAuthentication","useBrowserAutofill","allowCredentials","document","querySelectorAll","mediation","get","rpId","identifyAuthenticationError","userHandle","signature","isSupported","isAutofillable","isPlatformAuthenticator","isUserVerifyingPlatformAuthenticatorAvailable","pull","object","key","extracted","isObjectEmpty","value","Object","keys","mergeDeep","target","source","isObject","output","assign","forEach","obj","Array","isArray","normalizeOptions","config","defaultPathKey","routes","path","baseURL","origin","body","method","headers","redirect","defaultConfig","findCsrfToken","findXsrfToken","useAutofill","attestOptions","attest","assertOptions","assert","Accept","suspectProtoRx","suspectConstructorRx","JsonSigRx","jsonParseTransform","warnKeyDropped","destr","_value","trim","at","includes","slice","_lval","toLowerCase","Number","NaN","POSITIVE_INFINITY","NEGATIVE_INFINITY","strict","SyntaxError","JSON","parse","HASH_RE","AMPERSAND_RE","EQUAL_RE","PLUS_RE","ENC_CARET_RE","ENC_BACKTICK_RE","ENC_PIPE_RE","ENC_SPACE_RE","encodeQueryValue","input","text","stringify","encodeURI","encodeQueryKey","decode","decodeURIComponent","decodeQueryValue","parseQuery","parametersString","parameter","split","s","match","push","stringifyQuery","query","k","encodeQueryItem","join","Boolean","PROTOCOL_STRICT_REGEX","PROTOCOL_REGEX","PROTOCOL_RELATIVE_REGEX","hasProtocol","inputString","opts","acceptRelative","TRAILING_SLASH_RE","hasTrailingSlash","respectQueryAndFragment","endsWith","withTrailingSlash","fragment","fragmentIndex","s0","withBase","base","url","_base","withoutTrailingSlash","startsWith","segment","url2","isNonEmptyURL","_segment","JOIN_LEADING_SLASH_RE","joinURL","withQuery","parsed","parseURL","mergedQuery","search","pathname","hash","auth","host","proto","protocol","stringifyParsedURL","defaultProto","_specialProtoMatch","_proto","_pathname","href","parsePath","hostAndPath","Math","max","splice","FetchError","payloadMethods","Set","freeze","isPayloadMethod","has","toUpperCase","textTypes","JSON_RE","mergeFetchOptions","defaults","Headers","globalThis","merged","params","set","retryStatusCodes","nullBodyResponses","_globalThis","self","global","ofetch","createFetch","globalOptions","fetch","onError","context","isAbort","timeout","retry","retries","responseCode","status","retryDelay","setTimeout","$fetchRaw","request","ctx","errorMessage","toString","requestStr","statusStr","statusText","fetchError","defineProperty","refKey","createFetchError","captureStackTrace","_request","_options","onRequest","t","toJSON","isJSONSerializable","pipeTo","pipe","duplex","onRequestError","responseType","parseResponse","_contentType","contentType","shift","detectResponseType","data","parseFunction","_data","onResponse","ignoreResponseError","onResponseError","$fetch","raw","native","args","defaultOptions","reject","setToken","token","find","missingToken","from","head","getElementsByTagName","element","content","cookie","RegExp","findTokenInCookie","isCsrfToken","wfetch","webAuthnData","fetchOptions","pullTokenConfig","benchmark","start","Date","stop","diffInMs","getTime","minutes","floor","seconds","toFixed","newError","webpass","currentConfig","structuredClone","attestRaw","bench","normalizedOptions","normalizedResponseOptions","attestationOptions","debug","result","assertRaw","assertionOptions","success","jwt","uuid","Webpass","isNotSupported","isUnsupported","isNotAutofillable","isNotPlatformAuthenticator"],"mappings":"AACA,SAASA,EAAwBC,GAC7B,MAAMC,EAAQ,IAAIC,WAAWF,GAC7B,IAAIG,EAAM,GACV,IAAK,MAAMC,KAAYH,EACnBE,GAAOE,OAAOC,aAAaF,GAG/B,OADqBG,KAAKJ,GACNK,QAAQ,MAAO,KAAKA,QAAQ,MAAO,KAAKA,QAAQ,KAAM,GAC9E,CAEA,SAASC,EAAwBC,GAC7B,MAAMC,EAASD,EAAgBF,QAAQ,KAAM,KAAKA,QAAQ,KAAM,KAC1DI,GAAa,EAAKD,EAAOE,OAAS,GAAM,EACxCC,EAASH,EAAOI,OAAOJ,EAAOE,OAASD,EAAW,KAClDI,EAASC,KAAKH,GACdd,EAAS,IAAIkB,YAAYF,EAAOH,QAChCZ,EAAQ,IAAIC,WAAWF,GAC7B,IAAK,IAAImB,EAAI,EAAGA,EAAIH,EAAOH,OAAQM,IAC/BlB,EAAMkB,GAAKH,EAAOI,WAAWD,GAEjC,OAAOnB,CACX,CAEA,SAASqB,IACL,YAAwCC,IAAhCC,QAAQC,qBAC0B,mBAA/BD,OAAOC,mBACtB,CAEA,SAASC,EAAgCC,GACrC,MAAMC,GAAEA,GAAOD,EACf,MAAO,IACAA,EACHC,GAAIlB,EAAwBkB,GAC5BC,WAAYF,EAAWE,WAE/B,CAEA,SAASC,EAAcC,GACnB,MAAqB,cAAbA,GACJ,0CAA0CC,KAAKD,EACvD,CAEA,MAAME,UAAsBC,MACxB,WAAAC,EAAYC,QAAEA,EAAOC,KAAEA,EAAIC,MAAEA,EAAKC,KAAEA,IAChCC,MAAMJ,EAAS,CAAEE,UACjBG,KAAKF,KAAOA,GAAQD,EAAMC,KAC1BE,KAAKJ,KAAOA,CACf,EAsHL,MAAMK,EAAuB,IApB7B,MACI,oBAAAC,GACI,GAAIF,KAAKG,WAAY,CACjB,MAAMC,EAAa,IAAIX,MAAM,qDAC7BW,EAAWN,KAAO,aAClBE,KAAKG,WAAWE,MAAMD,EACzB,CACD,MAAME,EAAgB,IAAIC,gBAE1B,OADAP,KAAKG,WAAaG,EACXA,EAAcE,MACxB,CACD,cAAAC,GACI,GAAIT,KAAKG,WAAY,CACjB,MAAMC,EAAa,IAAIX,MAAM,kDAC7BW,EAAWN,KAAO,aAClBE,KAAKG,WAAWE,MAAMD,GACtBJ,KAAKG,gBAAarB,CACrB,CACJ,GAIC4B,EAAc,CAAC,iBAAkB,YACvC,SAASC,EAA0BC,GAC/B,GAAKA,KAGDF,EAAYG,QAAQD,GAAc,GAGtC,OAAOA,CACX,CAEAE,eAAeC,EAAkBC,GAC7B,IAAKnC,IACD,MAAM,IAAIY,MAAM,6CAEpB,MASMwB,EAAU,CAAEC,UATA,IACXF,EACHG,UAAWlD,EAAwB+C,EAAYG,WAC/CC,KAAM,IACCJ,EAAYI,KACfjC,GAAIlB,EAAwB+C,EAAYI,KAAKjC,KAEjDkC,mBAAoBL,EAAYK,oBAAoBC,IAAIrC,KAI5D,IAAIsC,EADJN,EAAQT,OAASP,EAAqBC,uBAEtC,IACIqB,QAAoBC,UAAUC,YAAYC,OAAOT,EACpD,CACD,MAAOU,GACH,MApJR,UAAmCC,MAAEA,EAAKX,QAAEA,IACxC,MAAMC,UAAEA,GAAcD,EACtB,IAAKC,EACD,MAAMzB,MAAM,mDAEhB,GAAmB,eAAfmC,EAAM9B,MACN,GAAImB,EAAQT,kBAAkBqB,YAC1B,OAAO,IAAIrC,EAAc,CACrBG,QAAS,iDACTC,KAAM,yBACNC,MAAO+B,SAId,GAAmB,oBAAfA,EAAM9B,KAA4B,CACvC,IAA6D,IAAzDoB,EAAUY,wBAAwBC,mBAClC,OAAO,IAAIvC,EAAc,CACrBG,QAAS,qFACTC,KAAM,8DACNC,MAAO+B,IAGV,GAA2D,aAAvDV,EAAUY,wBAAwBE,iBACvC,OAAO,IAAIxC,EAAc,CACrBG,QAAS,6EACTC,KAAM,wDACNC,MAAO+B,GAGlB,KACI,IAAmB,sBAAfA,EAAM9B,KACX,OAAO,IAAIN,EAAc,CACrBG,QAAS,8CACTC,KAAM,4CACNC,MAAO+B,IAGV,GAAmB,oBAAfA,EAAM9B,KACX,OAAO,IAAIN,EAAc,CACrBG,QAASiC,EAAMjC,QACfC,KAAM,uCACNC,MAAO+B,IAGV,GAAmB,sBAAfA,EAAM9B,KAEX,OAAqC,IADPoB,EAAUe,iBAAiBC,QAAQC,GAAyB,eAAfA,EAAMC,OACvD/D,OACf,IAAImB,EAAc,CACrBG,QAAS,wDACTC,KAAM,mCACNC,MAAO+B,IAGR,IAAIpC,EAAc,CACrBG,QAAS,wFACTC,KAAM,wDACNC,MAAO+B,IAGV,GAAmB,kBAAfA,EAAM9B,KAA0B,CACrC,MAAMuC,EAAkBtD,OAAOuD,SAAShD,SACxC,IAAKD,EAAcgD,GACf,OAAO,IAAI7C,EAAc,CACrBG,QAAS,GAAGZ,OAAOuD,SAAShD,gCAC5BM,KAAM,uBACNC,MAAO+B,IAGV,GAAIV,EAAUqB,GAAGpD,KAAOkD,EACzB,OAAO,IAAI7C,EAAc,CACrBG,QAAS,cAAcuB,EAAUqB,GAAGpD,iCACpCS,KAAM,sBACNC,MAAO+B,GAGlB,MACI,GAAmB,cAAfA,EAAM9B,MACX,GAAIoB,EAAUE,KAAKjC,GAAGqD,WAAa,GAAKtB,EAAUE,KAAKjC,GAAGqD,WAAa,GACnE,OAAO,IAAIhD,EAAc,CACrBG,QAAS,8CACTC,KAAM,+BACNC,MAAO+B,SAId,GAAmB,iBAAfA,EAAM9B,KACX,OAAO,IAAIN,EAAc,CACrBG,QAAS,sGACTC,KAAM,oCACNC,MAAO+B,GAEd,CACD,OAAOA,CACX,CAuDca,CAA0B,CAAEb,MAAOD,EAAKV,WACjD,CACD,IAAKM,EACD,MAAM,IAAI9B,MAAM,kCAEpB,MAAMN,GAAEA,EAAEuD,MAAEA,EAAKC,SAAEA,EAAQP,KAAEA,GAASb,EACtC,IAAInC,EAIAwD,EASAC,EAYAC,EApBJ,GAJsC,mBAA3BH,EAASI,gBAChB3D,EAAauD,EAASI,iBAGoB,mBAAnCJ,EAASK,sBAChB,IACIJ,EAA6BD,EAASK,uBACzC,CACD,MAAOpB,GACHqB,EAA2B,0BAA2BrB,EACzD,CAGL,GAAqC,mBAA1Be,EAASO,aAChB,IACI,MAAMC,EAAaR,EAASO,eACT,OAAfC,IACAN,EAAoBtF,EAAwB4F,GAEnD,CACD,MAAOvB,GACHqB,EAA2B,iBAAkBrB,EAChD,CAGL,GAA6C,mBAAlCe,EAASS,qBAChB,IACIN,EAA4BvF,EAAwBoF,EAASS,uBAChE,CACD,MAAOxB,GACHqB,EAA2B,yBAA0BrB,EACxD,CAEL,MAAO,CACHzC,KACAuD,MAAOnF,EAAwBmF,GAC/BC,SAAU,CACNU,kBAAmB9F,EAAwBoF,EAASU,mBACpDC,eAAgB/F,EAAwBoF,EAASW,gBACjDlE,aACAmE,mBAAoBX,EACpB1B,UAAW2B,EACXW,kBAAmBV,GAEvBV,OACAqB,uBAAwBlC,EAAWmC,4BACnCC,wBAAyBhD,EAA0BY,EAAWoC,yBAEtE,CACA,SAASV,EAA2BW,EAAY/D,GAC5CgE,QAAQC,KAAK,yFAAyFF,6CAAuD/D,EACjK,CAEA,SAASkE,IACL,IAAKlF,IACD,OAAO,IAAImF,SAASC,GAAYA,GAAQ,KAE5C,MAAMC,EAA4BnF,OAC7BC,oBACL,YAAkEF,IAA9DoF,EAA0BC,gCACnB,IAAIH,SAASC,GAAYA,GAAQ,KAErCC,EAA0BC,iCACrC,CAkDArD,eAAesD,EAAoBpD,EAAaqD,GAAqB,GACjE,IAAKxF,IACD,MAAM,IAAIY,MAAM,6CAEpB,IAAI6E,EACyC,IAAzCtD,EAAYsD,kBAAkBjG,SAC9BiG,EAAmBtD,EAAYsD,kBAAkBhD,IAAIrC,IAEzD,MAAMiC,EAAY,IACXF,EACHG,UAAWlD,EAAwB+C,EAAYG,WAC/CmD,oBAEErD,EAAU,CAAA,EAChB,GAAIoD,EAAoB,CACpB,UAAYN,IACR,MAAMtE,MAAM,8CAGhB,GADuB8E,SAASC,iBAAiB,mCAC9BnG,OAAS,EACxB,MAAMoB,MAAM,qGAEhBwB,EAAQwD,UAAY,cACpBvD,EAAUoD,iBAAmB,EAChC,CAGD,IAAI/C,EAFJN,EAAQC,UAAYA,EACpBD,EAAQT,OAASP,EAAqBC,uBAEtC,IACIqB,QAAoBC,UAAUC,YAAYiD,IAAIzD,EACjD,CACD,MAAOU,GACH,MAhFR,UAAqCC,MAAEA,EAAKX,QAAEA,IAC1C,MAAMC,UAAEA,GAAcD,EACtB,IAAKC,EACD,MAAMzB,MAAM,mDAEhB,GAAmB,eAAfmC,EAAM9B,MACN,GAAImB,EAAQT,kBAAkBqB,YAC1B,OAAO,IAAIrC,EAAc,CACrBG,QAAS,mDACTC,KAAM,yBACNC,MAAO+B,QAId,IAAmB,oBAAfA,EAAM9B,KACX,OAAO,IAAIN,EAAc,CACrBG,QAASiC,EAAMjC,QACfC,KAAM,uCACNC,MAAO+B,IAGV,GAAmB,kBAAfA,EAAM9B,KAA0B,CACrC,MAAMuC,EAAkBtD,OAAOuD,SAAShD,SACxC,IAAKD,EAAcgD,GACf,OAAO,IAAI7C,EAAc,CACrBG,QAAS,GAAGZ,OAAOuD,SAAShD,gCAC5BM,KAAM,uBACNC,MAAO+B,IAGV,GAAIV,EAAUyD,OAAStC,EACxB,OAAO,IAAI7C,EAAc,CACrBG,QAAS,cAAcuB,EAAUyD,mCACjC/E,KAAM,sBACNC,MAAO+B,GAGlB,MACI,GAAmB,iBAAfA,EAAM9B,KACX,OAAO,IAAIN,EAAc,CACrBG,QAAS,+GACTC,KAAM,oCACNC,MAAO+B,GAEd,CACD,OAAOA,CACX,CAkCcgD,CAA4B,CAAEhD,MAAOD,EAAKV,WACnD,CACD,IAAKM,EACD,MAAM,IAAI9B,MAAM,oCAEpB,MAAMN,GAAEA,EAAEuD,MAAEA,EAAKC,SAAEA,EAAQP,KAAEA,GAASb,EACtC,IAAIsD,EAIJ,OAHIlC,EAASkC,aACTA,EAAatH,EAAwBoF,EAASkC,aAE3C,CACH1F,KACAuD,MAAOnF,EAAwBmF,GAC/BC,SAAU,CACNa,kBAAmBjG,EAAwBoF,EAASa,mBACpDF,eAAgB/F,EAAwBoF,EAASW,gBACjDwB,UAAWvH,EAAwBoF,EAASmC,WAC5CD,cAEJzC,OACAqB,uBAAwBlC,EAAWmC,4BACnCC,wBAAyBhD,EAA0BY,EAAWoC,yBAEtE,UC3WgBoB,IACZ,OAAOlG,GACX,CAqBOiC,eAAekE,IAClB,OAAOD,WAAuBhB,GAClC,CAcOjD,eAAemE,IAClB,OAAOF,WDsUFlG,IAGEG,oBAAoBkG,gDAFhB,IAAIlB,SAASC,GAAYA,GAAQ,KCtUhD,CC/CgB,SAAAkB,EAAuDC,EAAWC,GAC9E,MAAMC,EAAYF,EAAOC,GAIzB,cAFOD,EAAOC,GAEPC,CACX,CAsBM,SAAUC,EAAcC,GAC1B,MAAwB,iBAAVA,IAAuBC,OAAOC,KAAKF,GAAOnH,MAC5D,CAKgB,SAAAsH,EAAwEC,EAAWC,GAC/F,IAAKC,EAASF,GACV,OAAOD,EAAU,GAAIE,GAGzB,MAAME,EAA8BN,OAAOO,OAAO,CAAE,EAAEJ,GAgBtD,OAdIE,EAASD,IACTJ,OAAOC,KAAKG,GAAQI,SAASZ,IACrBS,EAASD,EAAOR,IACVA,KAAOO,EAGTG,EAAOV,GAAOM,EAAUC,EAAOP,GAAMQ,EAAOR,IAF5CI,OAAOO,OAAOD,EAAQ,CAACV,CAACA,GAAMQ,EAAOR,KAKzCI,OAAOO,OAAOD,EAAQ,CAACV,CAACA,GAAMQ,EAAOR,IACxC,IAIFU,CACX,CAKA,SAASD,EAASI,GACd,OAAe,OAARA,IAAiBC,MAAMC,QAAQF,IAAuB,iBAARA,GAAmC,mBAARA,CACpF,UAKgBG,EACZpF,EACAqF,EACAC,GAuBA,OApBKtF,IACDA,EAAUqF,EAAOE,OAAOD,IAIL,iBAAZtF,IACPA,EAAU,CAAEwF,KAAMxF,IAItBA,EAAQwF,KAAOxF,EAAQwF,MAAQH,EAAOE,OAAOD,GAC7CtF,EAAQyF,QAAUzF,EAAQyF,SAAWJ,EAAOI,SAAW3H,OAAOuD,SAASqE,OAGvE1F,EAAQ2F,KAAO3F,EAAQ2F,MAAQ,CAAA,EAC/B3F,EAAQ4F,OAAS5F,EAAQ4F,QAAUP,EAAOO,OAC1C5F,EAAQ6F,QAAU7F,EAAQ6F,SAAWR,EAAOQ,QAC5C7F,EAAQ8F,SAAW9F,EAAQ8F,UAAYT,EAAOS,SAC9C9F,EAAQQ,YAAcR,EAAQQ,aAAe6E,EAAO7E,YAE7CR,CACX,CC9FA,IAAe+F,EAAA,CACXH,OAAQ,OACRE,SAAU,QACVL,aAAS5H,EACTmI,eAAe,EACfC,eAAe,EACfC,iBAAarI,EACb0H,OAAQ,CACJY,cAAe,uBACfC,OAAQ,eACRC,cAAe,uBACfC,OAAQ,gBAEZT,QAAS,CACLU,OAAU,mBACV,eAAgB,mBAChB,mBAAoB,kBAExB/F,YAAa,eCzBjB,MAAMgG,EAAiB,oIACjBC,EAAuB,iKACvBC,EAAY,2DAClB,SAASC,EAAmBvC,EAAKG,GAC/B,KAAY,cAARH,GAA+B,gBAARA,GAAyBG,GAA0B,iBAAVA,GAAsB,cAAeA,GAIzG,OAAOA,GAET,SAAwBH,GACtBxB,QAAQC,KAAK,qBAAqBuB,yCACpC,CAPIwC,CAAexC,EAInB,CAIA,SAASyC,EAAMtC,EAAOvE,EAAU,IAC9B,GAAqB,iBAAVuE,EACT,OAAOA,EAET,MAAMuC,EAASvC,EAAMwC,OACrB,GAEe,MAAbxC,EAAM,IAA+B,MAAjBA,EAAMyC,IAAI,KAAezC,EAAM0C,SAAS,MAE5D,OAAOH,EAAOI,MAAM,GAAI,GAE1B,GAAIJ,EAAO1J,QAAU,EAAG,CACtB,MAAM+J,EAAQL,EAAOM,cACrB,GAAc,SAAVD,EACF,OAAO,EAET,GAAc,UAAVA,EACF,OAAO,EAET,GAAc,cAAVA,EACF,OAEF,GAAc,SAAVA,EACF,OAAO,KAET,GAAc,QAAVA,EACF,OAAOE,OAAOC,IAEhB,GAAc,aAAVH,EACF,OAAOE,OAAOE,kBAEhB,GAAc,cAAVJ,EACF,OAAOE,OAAOG,iBAEjB,CACD,IAAKd,EAAUpI,KAAKiG,GAAQ,CAC1B,GAAIvE,EAAQyH,OACV,MAAM,IAAIC,YAAY,wBAExB,OAAOnD,CACR,CACD,IACE,GAAIiC,EAAelI,KAAKiG,IAAUkC,EAAqBnI,KAAKiG,GAAQ,CAClE,GAAIvE,EAAQyH,OACV,MAAM,IAAIjJ,MAAM,wCAElB,OAAOmJ,KAAKC,MAAMrD,EAAOoC,EAC1B,CACD,OAAOgB,KAAKC,MAAMrD,EACnB,CAAC,MAAO5D,GACP,GAAIX,EAAQyH,OACV,MAAM9G,EAER,OAAO4D,CACR,CACH,CCuBA,MAAMsD,EAAU,KACVC,EAAe,KAEfC,EAAW,KAEXC,EAAU,MACVC,EAAe,QACfC,EAAkB,QAElBC,EAAc,QAEdC,EAAe,QASrB,SAASC,EAAiBC,GACxB,OAPcC,EAOiB,iBAAVD,EAAqBA,EAAQX,KAAKa,UAAUF,GAN1DG,UAAU,GAAKF,GAAMxL,QAAQoL,EAAa,MAMwBpL,QAAQiL,EAAS,OAAOjL,QAAQqL,EAAc,KAAKrL,QAAQ8K,EAAS,OAAO9K,QAAQ+K,EAAc,OAAO/K,QAAQmL,EAAiB,KAAKnL,QAAQkL,EAAc,KAPvO,IAAgBM,CAQhB,CACA,SAASG,EAAeH,GACtB,OAAOF,EAAiBE,GAAMxL,QAAQgL,EAAU,MAClD,CAOA,SAASY,EAAOJ,EAAO,IACrB,IACE,OAAOK,mBAAmB,GAAKL,EACnC,CAAI,MACA,MAAO,GAAKA,CACb,CACH,CAOA,SAASM,EAAiBN,GACxB,OAAOI,EAAOJ,EAAKxL,QAAQiL,EAAS,KACtC,CAKA,SAASc,EAAWC,EAAmB,IACrC,MAAM5E,EAAS,CAAA,EACa,MAAxB4E,EAAiB,KACnBA,EAAmBA,EAAiB7B,MAAM,IAE5C,IAAK,MAAM8B,KAAaD,EAAiBE,MAAM,KAAM,CACnD,MAAMC,EAAIF,EAAUG,MAAM,kBAAoB,GAC9C,GAAID,EAAE9L,OAAS,EACb,SAEF,MAAMgH,EAnBDuE,EAmBsBO,EAAE,GAnBZnM,QAAQiL,EAAS,MAoBlC,GAAY,cAAR5D,GAA+B,gBAARA,EACzB,SAEF,MAAMG,EAAQsE,EAAiBK,EAAE,IAAM,SACnB,IAAhB/E,EAAOC,GACTD,EAAOC,GAAOG,EACLW,MAAMC,QAAQhB,EAAOC,IAC9BD,EAAOC,GAAKgF,KAAK7E,GAEjBJ,EAAOC,GAAO,CAACD,EAAOC,GAAMG,EAE/B,CACD,OAAOJ,CACT,CAaA,SAASkF,EAAeC,GACtB,OAAO9E,OAAOC,KAAK6E,GAAOrI,QAAQsI,QAAmB,IAAbD,EAAMC,KAAelJ,KAAKkJ,IAAMC,OAbjDpF,EAaiEmF,EAZnE,iBADOhF,EAa+D+E,EAAMC,KAZ/C,kBAAVhF,IACtCA,EAAQ3H,OAAO2H,IAEZA,EAGDW,MAAMC,QAAQZ,GACTA,EAAMlE,KAAKyG,GAAW,GAAG4B,EAAetE,MAAQiE,EAAiBvB,OAAW2C,KAAK,KAEnF,GAAGf,EAAetE,MAAQiE,EAAiB9D,KALzCmE,EAAetE,GAL1B,IAAyBA,EAAKG,CAawE,IAAEtD,OAAOyI,SAASD,KAAK,IAC7H,CA6GA,MAAME,EAAwB,gCACxBC,EAAiB,+BACjBC,EAA0B,wBAChC,SAASC,EAAYC,EAAaC,EAAO,IAIvC,MAHoB,kBAATA,IACTA,EAAO,CAAEC,eAAgBD,IAEvBA,EAAKvC,OACAkC,EAAsBrL,KAAKyL,GAE7BH,EAAetL,KAAKyL,MAAiBC,EAAKC,gBAAiBJ,EAAwBvL,KAAKyL,EACjG,CAKA,MAAMG,EAAoB,eAC1B,SAASC,EAAiB7B,EAAQ,GAAI8B,GACpC,OAAKA,EAGEF,EAAkB5L,KAAKgK,GAFrBA,EAAM+B,SAAS,IAG1B,CAkBA,SAASC,EAAkBhC,EAAQ,GAAI8B,GACrC,IAAKA,EACH,OAAO9B,EAAM+B,SAAS,KAAO/B,EAAQA,EAAQ,IAE/C,GAAI6B,EAAiB7B,GAAO,GAC1B,OAAOA,GAAS,IAElB,IAAI9C,EAAO8C,EACPiC,EAAW,GACf,MAAMC,EAAgBlC,EAAM1I,QAAQ,KACpC,GAAI4K,GAAiB,IACnBhF,EAAO8C,EAAMpB,MAAM,EAAGsD,GACtBD,EAAWjC,EAAMpB,MAAMsD,IAClBhF,GACH,OAAO+E,EAGX,MAAOE,KAAOvB,GAAK1D,EAAKyD,MAAM,KAC9B,OAAOwB,EAAK,KAAOvB,EAAE9L,OAAS,EAAI,IAAI8L,EAAEO,KAAK,OAAS,IAAMc,CAC9D,CAaA,SAASG,EAASpC,EAAOqC,GACvB,KA6BkBC,EA7BHD,IA8BQ,MAARC,GA9BSd,EAAYxB,GAClC,OAAOA,EA4BX,IAAoBsC,EA1BlB,MAAMC,EArDR,SAA8BvC,EAAQ,GAAI8B,GACxC,IAAKA,EACH,OAAQD,EAAiB7B,GAASA,EAAMpB,MAAM,GAAI,GAAKoB,IAAU,IAEnE,IAAK6B,EAAiB7B,GAAO,GAC3B,OAAOA,GAAS,IAElB,IAAI9C,EAAO8C,EACPiC,EAAW,GACf,MAAMC,EAAgBlC,EAAM1I,QAAQ,KAChC4K,GAAiB,IACnBhF,EAAO8C,EAAMpB,MAAM,EAAGsD,GACtBD,EAAWjC,EAAMpB,MAAMsD,IAEzB,MAAOC,KAAOvB,GAAK1D,EAAKyD,MAAM,KAC9B,OAAQwB,EAAGvD,MAAM,GAAI,IAAM,MAAQgC,EAAE9L,OAAS,EAAI,IAAI8L,EAAEO,KAAK,OAAS,IAAMc,CAC9E,CAqCgBO,CAAqBH,GACnC,OAAIrC,EAAMyC,WAAWF,GACZvC,EA+BX,SAAiBqC,KAASrC,GACxB,IAAIsC,EAAMD,GAAQ,GAClB,IAAK,MAAMK,KAAW1C,EAAMrH,QAAQgK,GANtC,SAAuBL,GACrB,OAAOA,GAAe,MAARA,CAChB,CAI+CM,CAAcD,KACzD,GAAIL,EAAK,CACP,MAAMO,EAAWH,EAAQjO,QAAQqO,EAAuB,IACxDR,EAAMN,EAAkBM,GAAOO,CACrC,MACMP,EAAMI,EAGV,OAAOJ,CACT,CAxCSS,CAAQR,EAAOvC,EACxB,CAYA,SAASgD,EAAUhD,EAAOgB,GACxB,MAAMiC,EAASC,EAASlD,GAClBmD,EAAc,IAAK3C,EAAWyC,EAAOG,WAAYpC,GAEvD,OADAiC,EAAOG,OAASrC,EAAeoC,GAgIjC,SAA4BF,GAC1B,MAAMI,EAAWJ,EAAOI,UAAY,GAC9BD,EAASH,EAAOG,QAAUH,EAAOG,OAAOX,WAAW,KAAO,GAAK,KAAOQ,EAAOG,OAAS,GACtFE,EAAOL,EAAOK,MAAQ,GACtBC,EAAON,EAAOM,KAAON,EAAOM,KAAO,IAAM,GACzCC,EAAOP,EAAOO,MAAQ,GACtBC,EAAQR,EAAOS,SAAWT,EAAOS,SAAW,KAAO,GACzD,OAAOD,EAAQF,EAAOC,EAAOH,EAAWD,EAASE,CACnD,CAvISK,CAAmBV,EAC5B,CAUA,MAAMH,EAAwB,SA6D9B,SAASI,EAASlD,EAAQ,GAAI4D,GAC5B,MAAMC,EAAqB7D,EAAMa,MAC/B,oDAEF,GAAIgD,EAAoB,CACtB,MAAS,CAAAC,EAAQC,EAAY,IAAMF,EACnC,MAAO,CACLH,SAAUI,EAAOhF,cACjBuE,SAAUU,EACVC,KAAMF,EAASC,EACfR,KAAM,GACNC,KAAM,GACNJ,OAAQ,GACRE,KAAM,GAET,CACD,IAAK9B,EAAYxB,EAAO,CAAE2B,gBAAgB,IACxC,OAAOiC,EAAeV,EAASU,EAAe5D,GAASiE,EAAUjE,GAEnE,MAAM,CAAG0D,EAAW,GAAIH,EAAMW,EAAc,IAAMlE,EAAMvL,QAAQ,MAAO,KAAKoM,MAAM,8CAAgD,IACzH,CAAA2C,EAAO,GAAItG,EAAO,IAAMgH,EAAYrD,MAAM,mBAAqB,IAClEwC,SAAEA,EAAQD,OAAEA,EAAME,KAAEA,GAASW,EACjC/G,EAAKzI,QAAQ,kBAAmB,KAElC,MAAO,CACLiP,SAAUA,EAAS5E,cACnByE,KAAMA,EAAOA,EAAK3E,MAAM,EAAGuF,KAAKC,IAAI,EAAGb,EAAKzO,OAAS,IAAM,GAC3D0O,OACAH,WACAD,SACAE,OAEJ,CACA,SAASW,EAAUjE,EAAQ,IACzB,MAAOqD,EAAW,GAAID,EAAS,GAAIE,EAAO,KAAOtD,EAAMa,MAAM,6BAA+B,IAAIwD,OAAO,GACvG,MAAO,CACLhB,WACAD,SACAE,OAEJ,CCjfA,MAAMgB,UAAmBpO,MACvB,WAAAC,CAAYC,EAASsL,GACnBlL,MAAMJ,EAASsL,GACfjL,KAAKF,KAAO,aACRmL,GAAMpL,QAAUG,KAAKH,QACvBG,KAAKH,MAAQoL,EAAKpL,MAErB,EAoCH,MAAMiO,GAAiB,IAAIC,IACzBtI,OAAOuI,OAAO,CAAC,QAAS,OAAQ,MAAO,YAEzC,SAASC,GAAgBpH,EAAS,OAChC,OAAOiH,GAAeI,IAAIrH,EAAOsH,cACnC,CAoBA,MAAMC,GAA4B,IAAIL,IAAI,CACxC,YACA,kBACA,oBACA,qBAEIM,GAAU,oDAchB,SAASC,GAAkB/E,EAAOgF,EAAUC,EAAUC,WAAWD,SAC/D,MAAME,EAAS,IACVH,KACAhF,GAcL,GAZIgF,GAAUI,QAAUpF,GAAOoF,SAC7BD,EAAOC,OAAS,IACXJ,GAAUI,UACVpF,GAAOoF,SAGVJ,GAAUhE,OAAShB,GAAOgB,QAC5BmE,EAAOnE,MAAQ,IACVgE,GAAUhE,SACVhB,GAAOgB,QAGVgE,GAAUzH,SAAWyC,GAAOzC,QAAS,CACvC4H,EAAO5H,QAAU,IAAI0H,EAAQD,GAAUzH,SAAW,CAAA,GAClD,IAAK,MAAOzB,EAAKG,KAAU,IAAIgJ,EAAQjF,GAAOzC,SAAW,CAAA,GACvD4H,EAAO5H,QAAQ8H,IAAIvJ,EAAKG,EAE3B,CACD,OAAOkJ,CACT,CAEA,MAAMG,GAAmC,IAAId,IAAI,CAC/C,IAEA,IAEA,IAEA,IAEA,IAEA,IAEA,IAEA,MAGIe,GAAoC,IAAIf,IAAI,CAAC,IAAK,IAAK,IAAK,MClIlE,MAAMgB,GAAc,WAClB,GAA0B,oBAAfN,WACT,OAAOA,WAET,GAAoB,oBAATO,KACT,OAAOA,KAET,GAAsB,oBAAXjQ,OACT,OAAOA,OAET,GAAsB,oBAAXkQ,OACT,OAAOA,OAET,MAAM,IAAIxP,MAAM,iCAClB,CAdoB,GAkBdyP,GDiHN,SAASC,EAAYC,EAAgB,IACnC,MAAMC,MACJA,EAAQZ,WAAWY,MAAKb,QACxBA,EAAUC,WAAWD,QAAOjO,gBAC5BA,EAAkBkO,WAAWlO,iBAC3B6O,EACJtO,eAAewO,EAAQC,GACrB,MAAMC,EAAUD,EAAQ3N,OAAgC,eAAvB2N,EAAQ3N,MAAM9B,OAA0ByP,EAAQtO,QAAQwO,UAAW,EACpG,IAA8B,IAA1BF,EAAQtO,QAAQyO,QAAoBF,EAAS,CAC/C,IAAIG,EAEFA,EADmC,iBAA1BJ,EAAQtO,QAAQyO,MACfH,EAAQtO,QAAQyO,MAEhBzB,GAAgBsB,EAAQtO,QAAQ4F,QAAU,EAAI,EAE1D,MAAM+I,EAAeL,EAAQ5M,UAAY4M,EAAQ5M,SAASkN,QAAU,IACpE,GAAIF,EAAU,IAAMxJ,MAAMC,QAAQmJ,EAAQtO,QAAQ4N,kBAAoBU,EAAQtO,QAAQ4N,iBAAiB3G,SAAS0H,GAAgBf,GAAiBX,IAAI0B,IAAgB,CACnK,MAAME,EAAaP,EAAQtO,QAAQ6O,YAAc,EAIjD,OAHIA,EAAa,SACT,IAAI9L,SAASC,GAAY8L,WAAW9L,EAAS6L,KAE9CE,EAAUT,EAAQU,QAAS,IAC7BV,EAAQtO,QACXyO,MAAOC,EAAU,EACjBF,QAASF,EAAQtO,QAAQwO,SAE5B,CACF,CACD,MAAM7N,EAxJV,SAA0BsO,GACxB,MAAMC,EAAeD,EAAItO,OAAOjC,SAAWuQ,EAAItO,OAAOwO,YAAc,GAC9DvJ,EAASqJ,EAAID,SAASpJ,QAAUqJ,EAAIjP,SAAS4F,QAAU,MACvDgF,EAAMqE,EAAID,SAASpE,KAAOhO,OAAOqS,EAAID,UAAY,IACjDI,EAAa,IAAIxJ,MAAW+B,KAAKa,UAAUoC,KAC3CyE,EAAYJ,EAAIvN,SAAW,GAAGuN,EAAIvN,SAASkN,UAAUK,EAAIvN,SAAS4N,aAAe,gBAEjFC,EAAa,IAAI3C,EADP,GAAGwC,MAAeC,IAAYH,EAAe,IAAIA,IAAiB,KAGhFD,EAAItO,MAAQ,CAAE/B,MAAOqQ,EAAItO,YAAU,GAErC,IAAK,MAAMyD,IAAO,CAAC,UAAW,UAAW,YACvCI,OAAOgL,eAAeD,EAAYnL,EAAK,CACrCX,IAAG,IACMwL,EAAI7K,KAIjB,IAAK,MAAOA,EAAKqL,IAAW,CAC1B,CAAC,OAAQ,SACT,CAAC,SAAU,UACX,CAAC,aAAc,UACf,CAAC,aAAc,cACf,CAAC,gBAAiB,eAElBjL,OAAOgL,eAAeD,EAAYnL,EAAK,CACrCX,IAAG,IACMwL,EAAIvN,UAAYuN,EAAIvN,SAAS+N,KAI1C,OAAOF,CACT,CAwHkBG,CAAiBpB,GAI/B,MAHI9P,MAAMmR,mBACRnR,MAAMmR,kBAAkBhP,EAAOoO,GAE3BpO,CACP,CACD,MAAMoO,EAAYlP,eAA0B+P,EAAUC,EAAW,CAAA,GAC/D,MAAMvB,EAAU,CACdU,QAASY,EACT5P,QAASqN,GAAkBwC,EAAU1B,EAAcb,SAAUC,GAC7D7L,cAAU,EACVf,WAAO,GAqCT,GAnCA2N,EAAQtO,QAAQ4F,OAAS0I,EAAQtO,QAAQ4F,QAAQsH,cAC7CoB,EAAQtO,QAAQ8P,iBACZxB,EAAQtO,QAAQ8P,UAAUxB,GAEH,iBAApBA,EAAQU,UACbV,EAAQtO,QAAQyF,UAClB6I,EAAQU,QAAUtE,EAAS4D,EAAQU,QAASV,EAAQtO,QAAQyF,WAE1D6I,EAAQtO,QAAQsJ,OAASgF,EAAQtO,QAAQ0N,UAC3CY,EAAQU,QAAU1D,EAAUgD,EAAQU,QAAS,IACxCV,EAAQtO,QAAQ0N,UAChBY,EAAQtO,QAAQsJ,UAIrBgF,EAAQtO,QAAQ2F,MAAQqH,GAAgBsB,EAAQtO,QAAQ4F,WA5IhE,SAA4BrB,GAC1B,QAAc,IAAVA,EACF,OAAO,EAET,MAAMwL,SAAWxL,EACjB,MAAU,WAANwL,GAAwB,WAANA,GAAwB,YAANA,GAAyB,OAANA,GAGjD,WAANA,MAGA7K,MAAMC,QAAQZ,KAGdA,EAAMhI,SAGHgI,EAAM9F,aAA0C,WAA3B8F,EAAM9F,YAAYI,MAA6C,mBAAjB0F,EAAMyL,QAClF,CA2HUC,CAAmB3B,EAAQtO,QAAQ2F,OAWrC,WAAY2I,EAAQtO,QAAQ2F,MAA+C,mBAAhC2I,EAAQtO,QAAQ2F,KAAKuK,QAC3B,mBAA9B5B,EAAQtO,QAAQ2F,KAAKwK,QAEtB,WAAY7B,EAAQtO,UACxBsO,EAAQtO,QAAQoQ,OAAS,UAd3B9B,EAAQtO,QAAQ2F,KAAuC,iBAAzB2I,EAAQtO,QAAQ2F,KAAoB2I,EAAQtO,QAAQ2F,KAAOgC,KAAKa,UAAU8F,EAAQtO,QAAQ2F,MACxH2I,EAAQtO,QAAQ6F,QAAU,IAAI0H,EAAQe,EAAQtO,QAAQ6F,SAAW,CAAA,GAC5DyI,EAAQtO,QAAQ6F,QAAQoH,IAAI,iBAC/BqB,EAAQtO,QAAQ6F,QAAQ8H,IAAI,eAAgB,oBAEzCW,EAAQtO,QAAQ6F,QAAQoH,IAAI,WAC/BqB,EAAQtO,QAAQ6F,QAAQ8H,IAAI,SAAU,uBAYvCW,EAAQtO,QAAQT,QAAU+O,EAAQtO,QAAQwO,QAAS,CACtD,MAAMtP,EAAa,IAAII,EACvBwP,YAAW,IAAM5P,EAAWE,SAASkP,EAAQtO,QAAQwO,SACrDF,EAAQtO,QAAQT,OAASL,EAAWK,MACrC,CACD,IACE+O,EAAQ5M,eAAiB0M,EACvBE,EAAQU,QACRV,EAAQtO,QAEX,CAAC,MAAOW,GAKP,OAJA2N,EAAQ3N,MAAQA,EACZ2N,EAAQtO,QAAQqQ,sBACZ/B,EAAQtO,QAAQqQ,eAAe/B,SAE1BD,EAAQC,EACtB,CAED,GADgBA,EAAQ5M,SAASiE,OAASkI,GAAkBZ,IAAIqB,EAAQ5M,SAASkN,SAAsC,SAA3BN,EAAQtO,QAAQ4F,OAC/F,CACX,MAAM0K,GAAgBhC,EAAQtO,QAAQuQ,cAAgB,OAASjC,EAAQtO,QAAQsQ,eAzJrF,SAA4BE,EAAe,IACzC,IAAKA,EACH,MAAO,OAET,MAAMC,EAAcD,EAAavH,MAAM,KAAKyH,SAAW,GACvD,OAAItD,GAAQ9O,KAAKmS,GACR,OAELtD,GAAUF,IAAIwD,IAAgBA,EAAY1F,WAAW,SAChD,OAEF,MACT,CA6IsG4F,CAAmBrC,EAAQ5M,SAASmE,QAAQpC,IAAI,iBAAmB,IACnK,OAAQ6M,GACN,IAAK,OAAQ,CACX,MAAMM,QAAatC,EAAQ5M,SAAS6G,OAC9BsI,EAAgBvC,EAAQtO,QAAQuQ,eAAiB1J,EACvDyH,EAAQ5M,SAASoP,MAAQD,EAAcD,GACvC,KACD,CACD,IAAK,SACHtC,EAAQ5M,SAASoP,MAAQxC,EAAQ5M,SAASiE,KAC1C,MAEF,QACE2I,EAAQ5M,SAASoP,YAAcxC,EAAQ5M,SAAS4O,KAGrD,CAID,OAHIhC,EAAQtO,QAAQ+Q,kBACZzC,EAAQtO,QAAQ+Q,WAAWzC,IAE9BA,EAAQtO,QAAQgR,qBAAuB1C,EAAQ5M,SAASkN,QAAU,KAAON,EAAQ5M,SAASkN,OAAS,KAClGN,EAAQtO,QAAQiR,uBACZ3C,EAAQtO,QAAQiR,gBAAgB3C,SAE3BD,EAAQC,IAEhBA,EAAQ5M,QACnB,EACQwP,EAASrR,eAAuBmP,EAAShP,GAE7C,aADgB+O,EAAUC,EAAShP,IAC1B8Q,KACb,EAUE,OATAI,EAAOC,IAAMpC,EACbmC,EAAOE,OAAS,IAAIC,IAASjD,KAASiD,GACtCH,EAAOzQ,OAAS,CAAC6Q,EAAiB,CAAA,IAAOpD,EAAY,IAChDC,EACHb,SAAU,IACLa,EAAcb,YACdgE,KAGAJ,CACT,CC1PehD,CAAY,CAAEE,MAHfN,GAAYM,OAAK,KAAWrL,QAAQwO,OAAO,IAAI/S,MAAM,6CAG/B+O,QAFpBO,GAAYP,QAEejO,gBADnBwO,GAAYxO,kBCIpC,SAASkS,GAASC,EAAuB5L,IAEvB,IAAV4L,GApBR,SAAsB5L,GAClB,OAASrB,OAAOC,KAAKoB,GAChB6L,MAAMtN,GACI,CAAC,eAAgB,gBAAgB6C,SAAS7C,EAAIgD,kBAC5CvB,EAAQzB,IAE7B,CAc0BuN,CAAa9L,KAC/B4L,ECXGvM,MACF0M,KAAKtO,SAASuO,KAAKC,qBAAqB,SACxCJ,MAAMK,GAAqE,eAA/BA,EAAQlT,KAAKuI,iBAAoC2K,EAAQC,WACpGA,SAQC9M,MACF0M,KAAKtO,SAASqC,KAAKmM,qBAAqB,UACxCJ,MAAMpJ,GACiC,WAA7BA,EAAMzJ,KAAKuI,eACkB,WAA7BkB,EAAMnH,KAAKiG,iBACTkB,EAAM/D,SAEjBA,kBA7BN,MAAM4E,EAA+B7F,SAAS2O,OAAO9I,MACjD,IAAI+I,OAAO,mCAAoC,MAGnD,OAAO/I,EAAQP,mBAAmBO,EAAM,SAAMtL,CAClD,CDiB2DsU,IAAuB,IAIzD,iBAAVV,IACP5L,ECQF,SAAsB4L,GACxB,GAAIA,EAAMrU,OAAS,GAAI,CACnB,MAAMuD,EAAQ,IAAInC,MAAM,4DAIxB,MAFAmC,EAAM9B,KAAO,eAEP8B,CACT,CAED,OAAwB,KAAjB8Q,EAAMrU,MACjB,CDlBgBgV,CAAYX,GAAS,eAAiB,gBAAkBA,EAExE,CAEA,IAAAY,GAAexS,MAAUG,EAA0BsS,EAAuB,MACtE,MAAM9M,KAACA,KAAS+M,GAAgBvS,EAShC,OAPAuS,EAAa1M,QAAU0M,EAAa1M,SAAW,CAAA,EAE/C2L,GAxBJ,SAAyBxR,GACrB,OAAOkE,EAAKlE,EAAS,kBAAoBkE,EAAKlE,EAAS,gBAC3D,CAsBawS,CAAgBxS,GAAUuS,EAAa1M,SAGhD0M,EAAa5M,KAAOjB,EAAU6N,EAAa5M,MAAQ,CAAA,EAAI2M,SAE1CrE,GAAUzI,EAAM+M,EAAa,EE7C9CE,GAAe,KACX,MAAMC,EAAQ,IAAIC,KAElB,MAAO,CACHD,QACAE,KAAM,KACF,MAAMC,GAAmB,IAAIF,MAAOG,UAAYJ,EAAMI,UAEhDC,EAAkBtG,KAAKuG,MAAMH,EAAW,KACxCI,EAAkB5L,QAASwL,EAAW,IAAS,KAAMK,QAAQ,IAEnE,OAAQH,EAAUA,EAAU,aAAe,KAAOE,EAAUA,EAAU,YAAc,GAAG,EAE9F,ECcL,SAASE,GAAStU,EAAcH,EAAiBE,OAAiBf,GAC9D,MAAM8C,EAAQ,IAAInC,MAAME,GAKxB,OAHAiC,EAAM9B,KAAOA,EACb8B,EAAM/B,MAAQA,EAEP+B,CACX,CAMA,SAASyS,GAAQ/N,EAA0B,IAEvC,MAAMgO,EAAwB3O,EAAU4O,gBAAgBvN,GAAgBV,GAmCxExF,eAAe0T,EAAUvT,EAA+C0B,GACpE,MAAM8R,EAAQf,KAGRgB,EAAoBrO,EAAiBpF,EAASqT,EAAe,iBAC7DK,EAA4BtO,EAAiB1D,EAAU2R,EAAe,UAGtEM,QAAiFtB,GAA6DoB,GAKpJ,GAHA7Q,QAAQgR,MAAM,+BAAgCD,IAGzCA,GAAsBrP,EAAcqP,GACrC,MAAMR,GAAS,6BAA8B,2EAGjD,IAAI3S,EAEJ,IACIA,QAAoBV,EAAkB6T,EACzC,CAAC,MAAO/U,GACL,MAAMuU,GAAS,uBAAwB,8CAA+CvU,EACzF,CAEDgE,QAAQgR,MAAM,kCAAmCpT,GAEjD,MAAMqT,QAAexB,GAA4BqB,EAA2BlT,GAI5E,OAFAoC,QAAQgR,MAAM,wBAAyBJ,EAAMZ,QAEtCiB,CACV,CA2CDhU,eAAeiU,EAAU9T,EAA+C0B,GACpE,MAAM8R,EAAQf,KAGRgB,EAAoBrO,EAAiBpF,EAASqT,EAAe,iBAC7DK,EAA4BtO,EAAiB1D,EAAU2R,EAAe,UAGtEU,QAA8E1B,GAA4DoB,GAKhJ,GAHA7Q,QAAQgR,MAAM,6BAA8BG,IAGvCA,GAAoBzP,EAAcyP,GACnC,MAAMZ,GAAS,2BAA4B,0EAG/C,IAAI3S,EAEJ,IACIA,QAAoB2C,EAChB4Q,EACAN,EAAkBvN,aAAewN,EAA0BxN,aAAemN,EAAcnN,YAE/F,CAAC,MAAOtH,GACL,MAAMuU,GAAS,qBAAsB,6CAA8CvU,EACtF,CAEDgE,QAAQgR,MAAM,kCAAmCpT,GAGjD,MAAMqT,QAAexB,GAA+BqB,EAA2BlT,GAI/E,OAFAoC,QAAQgR,MAAM,sBAAuBJ,EAAMZ,QAEpCiB,CACV,CAED,MAAO,CACHvN,OA7EJzG,eAAsBG,EAA+C0B,GAEjE,MAAMmS,EAA0B,CAC5BjD,UAAM/S,EACNsC,UAAMtC,EACN4T,WAAO5T,EACPmW,SAAS,EACTrT,WAAO9C,GAIX,IACIgW,EAAOjD,WAAakD,EAAU9T,EAAS0B,EAC1C,CAAC,MAAOf,GACL,MAAO,IAAIkT,EAAQlT,QACtB,CAAS,QACNkT,EAAOG,aAA2BnW,IAAjBgW,EAAOlT,KAC3B,CAeD,MAZ2B,iBAAhBkT,EAAOjD,MACdiD,EAAO1T,KAAmC,iBAArB0T,EAAOjD,KAAKzQ,KAAoB0T,EAAOjD,KAAKzQ,KAAO0T,EAAOjD,KAC/EiD,EAAOpC,MAAQoC,EAAOjD,MAAMa,OAASoC,EAAOjD,MAAMqD,IAG7CJ,EAAOpC,OAAgC,iBAAhBoC,EAAO1T,OAC/B0T,EAAOpC,MAAQoC,EAAO1T,MAAMsR,OAASoC,EAAO1T,MAAM8T,MAExB,iBAAhBJ,EAAOjD,OACrBiD,EAAOpC,MAAQoC,EAAOjD,MAGnBiD,CACV,EA6CGzN,OAjJJvG,eAAsBG,EAA+C0B,GAEjE,MAAMmS,EAA4B,CAC9BjD,UAAM/S,EACN2C,iBAAa3C,EACbK,QAAIL,EACJmW,SAAS,EACTrT,WAAO9C,GAIX,IACIgW,EAAOjD,KAAOiD,EAAOrT,kBAAoB+S,EAAUvT,EAAS0B,EAC/D,CAAC,MAAOf,GACL,MAAO,IAAIkT,EAAQlT,QACtB,CAAS,QACNkT,EAAOG,aAA2BnW,IAAjBgW,EAAOlT,KAC3B,CAOD,MAJ2B,iBAAhBkT,EAAOjD,OACdiD,EAAO3V,GAAK2V,EAAOjD,MAAM1S,IAAM2V,EAAOjD,MAAMsD,MAGzCL,CACV,EAyHGC,YACAP,YAER,CAEA,IAAeY,GAAA,CACX1T,OAAQ2S,GACRhN,OAAQvG,MAAOG,EAAU0B,UAAqB0R,KAAWhN,OAAOpG,EAAS0B,GACzE4E,OAAQzG,MAAOG,EAAU0B,UAAqB0R,KAAW9M,OAAOtG,EAAS0B,GACzE6R,UAAW1T,MAAOG,EAAU0B,UAAqB0R,KAAWG,UAAUvT,EAAS0B,GAC/EoS,UAAWjU,MAAOG,EAAU0B,UAAqB0R,KAAWU,UAAU9T,EAAS0B,GAC/EoC,cACAsQ,0BV7LA,OAAStQ,GACb,EU6LIuQ,yBVvLA,OAASvQ,GACb,EUuLIC,iBACAuQ,kBVxKGzU,iBACH,aAAekE,GACnB,EUuKIC,0BACAuQ,2BV5JG1U,iBACH,aAAemE,GACnB","x_google_ignoreList":[0,4,5,6,7]}